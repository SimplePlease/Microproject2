#include <iostream>
#include <thread>
#include <vector>
#include "semaphore.h"

/**
 * Выполнила: студентка БПИ199 Вахитова Диана Рафиковна.
 * --------------------------------------------------------------------------
 * Условие: Задача об обедающих философах. 
 * Пять философов сидят возле
 * круглого стола. Они проводят жизнь, чередуя приемы пищи и размышления.
 * В центре стола находится большое блюдо спагетти. Спагетти длинные и
 * запутанные, философам тяжело управляться с ними, поэтому каждый из них,
 * что бы съесть порцию, должен пользоваться двумя вилками. К несчастью,
 * философам дали только пять вилок. Между каждой парой философов лежит
 * одна вилка, поэтому эти высококультурные и предельно вежливые люди
 * договорились, что каждый будет пользоваться только теми вилками, которые
 * лежат рядом с ним (слева и справа). Написать многопоточную программу,
 * моделирующую поведение философов с помощью семафоров.
 * ----------------------------------------------------------------------- 
 * Примечание: Программа должна избегать фатальной ситуации, в которой все философы голодны, но
 * ни один из них не может взять обе вилки (например, каждый из философов
 * держит по одной вилки и не хочет отдавать ее). Решение должно быть
 * симметричным, то есть все потоки-философы должны выполнять один и тот
 * же код.
 */

using namespace std;

// Число философов. 
const int philosophers_num = 5;
// Количество раз, котоое поест каждый философ. 
int eating_num;
// Время размышлений до приема пищи. 
const int secsToThink = 3;
// Время приема пищи. 
const int secsToEat = 2;
// Время задержки в миллисекундах после вывода текста
const int afterOutputPauseTimeMilliSec = 250;

// Вектор семафоров, отвечающих за вилки. Работать будут скорее как мутекс - вилка занята/не знаята. 
vector<sem_t*> forks = vector<sem_t*>(5);

// Метод, симулирующий проблему. 
void eat_and_think(int id) {
    // Выбор вилки с наименьшим и наибольшим номером
    int firstForkInd = id;
    int secondForkInd = (id + 1) % philosophers_num;
    if (firstForkInd > secondForkInd)
        swap(firstForkInd, secondForkInd);
    sem_t* firstFork = forks[firstForkInd];
    sem_t* secondFork = forks[secondForkInd];

    for (int i = 0; i < eating_num; ++i) {
        printf("Философ %d размышляет.\n", id+1);
        this_thread::sleep_for(chrono::seconds(secsToThink));

        // Философ сначала берет вилку с наименьшим номером
        printf("Философ %d хочет взять первую вилку под номером %d.\n", id+1, firstForkInd+1);
        sem_wait(firstFork);
        printf("Философ %d взял первую вилку под номером %d.\n", id+1, firstForkInd+1);
        printf("Философ %d хочет взять вторую вилку под номером %d.\n", id+1, secondForkInd+1);
        sem_wait(secondFork);
        printf("Философ %d взял вторую вилку под номером %d.\n", id+1, secondForkInd+1);
        // И только потом уже берет вильку с наибольшим номером
        
        printf("Философ %d кушает.\n", id+1);
        this_thread::sleep_for(chrono::seconds(secsToEat));

        // Кладет сначала вилку с наибольшим номером, затем с наименьшим
        sem_post(secondFork);
        sem_post(firstFork);
        printf("Философ %d поел и продолжил рассуждать на тему бренности бытия.\n", id+1);
    }
}

/**
 * Вызов функций и создание потоков.
 */
int main() {
    // Спрашиваем у пользователя, сколько раз он хочет, чтобы философы поели до окончания работы программы. 
    // Делаем небольшую "защиту от дурака".
    double temp;
    
    do {
        cout << "Введите, сколько раз вы хотите, чтобы каждый философ поел. (от 1 до 100)\n";
        cin >> temp;
        int b = static_cast<int>(temp);
        if ((double)b != temp) temp = -1;
    } while (temp <= 0 || temp> 100 || static_cast<int>(temp) != temp);
    eating_num = temp;

    for (size_t i = 0; i < philosophers_num; i++)
    {
        // Семафоры, которые по факту мьютексы. 
        forks[i] = new sem_t();
        sem_init(forks[i], 1, 1);
    }

    thread* philosophers = new thread[philosophers_num];
    for (int i = 0; i < philosophers_num; ++i) {
        philosophers[i] = thread(eat_and_think, i);
    }

    // Объединение потоков. 
    for (int i = 0; i < philosophers_num; ++i) {
        philosophers[i].join();
    }
 
    // Чистим память. 
    delete[] philosophers;

    // Ура. 
    cout << "Программа закончила выполнение без взаимной блокировки. Ура-ура!" << endl;
    return 0;
}